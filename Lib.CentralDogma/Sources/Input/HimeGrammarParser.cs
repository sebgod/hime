/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 1.0.0.0
 */

using System.Collections.Generic;
using Hime.Redist;
using Hime.Redist.Parsers;

namespace Hime.CentralDogma.Input
{
	/// <summary>
	/// Represents a parser
	/// </summary>
	internal class HimeGrammarParser : LRkParser
	{
        private static readonly LRkAutomaton automaton = LRkAutomaton.Find(typeof(HimeGrammarParser), "HimeGrammarParser.bin");
		/// <summary>
		/// Contains the constant IDs for the variables and virtuals in this parser
		/// </summary>
		public sealed class ID
		{
			/// <summary>
			/// The unique identifier for variable option
			/// </summary>
			public const int option = 0x1E;
			/// <summary>
			/// The unique identifier for variable terminal_def_atom
			/// </summary>
			public const int terminal_def_atom = 0x1F;
			/// <summary>
			/// The unique identifier for variable terminal_def_element
			/// </summary>
			public const int terminal_def_element = 0x20;
			/// <summary>
			/// The unique identifier for variable terminal_def_cardinalilty
			/// </summary>
			public const int terminal_def_cardinalilty = 0x21;
			/// <summary>
			/// The unique identifier for variable terminal_def_repetition
			/// </summary>
			public const int terminal_def_repetition = 0x22;
			/// <summary>
			/// The unique identifier for variable terminal_def_fragment
			/// </summary>
			public const int terminal_def_fragment = 0x23;
			/// <summary>
			/// The unique identifier for variable terminal_def_restrict
			/// </summary>
			public const int terminal_def_restrict = 0x24;
			/// <summary>
			/// The unique identifier for variable terminal_definition
			/// </summary>
			public const int terminal_definition = 0x25;
			/// <summary>
			/// The unique identifier for variable terminal
			/// </summary>
			public const int terminal = 0x26;
			/// <summary>
			/// The unique identifier for variable rule_sym_action
			/// </summary>
			public const int rule_sym_action = 0x27;
			/// <summary>
			/// The unique identifier for variable rule_sym_virtual
			/// </summary>
			public const int rule_sym_virtual = 0x28;
			/// <summary>
			/// The unique identifier for variable rule_sym_ref_params
			/// </summary>
			public const int rule_sym_ref_params = 0x29;
			/// <summary>
			/// The unique identifier for variable rule_sym_ref_template
			/// </summary>
			public const int rule_sym_ref_template = 0x2A;
			/// <summary>
			/// The unique identifier for variable rule_sym_ref_simple
			/// </summary>
			public const int rule_sym_ref_simple = 0x2B;
			/// <summary>
			/// The unique identifier for variable rule_def_atom
			/// </summary>
			public const int rule_def_atom = 0x2C;
			/// <summary>
			/// The unique identifier for variable rule_def_element
			/// </summary>
			public const int rule_def_element = 0x2D;
			/// <summary>
			/// The unique identifier for variable rule_def_tree_action
			/// </summary>
			public const int rule_def_tree_action = 0x2E;
			/// <summary>
			/// The unique identifier for variable rule_def_repetition
			/// </summary>
			public const int rule_def_repetition = 0x2F;
			/// <summary>
			/// The unique identifier for variable rule_def_fragment
			/// </summary>
			public const int rule_def_fragment = 0x30;
			/// <summary>
			/// The unique identifier for variable rule_def_choice
			/// </summary>
			public const int rule_def_choice = 0x31;
			/// <summary>
			/// The unique identifier for variable rule_definition
			/// </summary>
			public const int rule_definition = 0x32;
			/// <summary>
			/// The unique identifier for variable rule_template_params
			/// </summary>
			public const int rule_template_params = 0x33;
			/// <summary>
			/// The unique identifier for variable cf_rule_template
			/// </summary>
			public const int cf_rule_template = 0x34;
			/// <summary>
			/// The unique identifier for variable cf_rule_simple
			/// </summary>
			public const int cf_rule_simple = 0x35;
			/// <summary>
			/// The unique identifier for variable grammar_options
			/// </summary>
			public const int grammar_options = 0x36;
			/// <summary>
			/// The unique identifier for variable grammar_terminals
			/// </summary>
			public const int grammar_terminals = 0x37;
			/// <summary>
			/// The unique identifier for variable grammar_cf_rules
			/// </summary>
			public const int grammar_cf_rules = 0x38;
			/// <summary>
			/// The unique identifier for variable grammar_parency
			/// </summary>
			public const int grammar_parency = 0x39;
			/// <summary>
			/// The unique identifier for variable cf_grammar
			/// </summary>
			public const int cf_grammar = 0x3A;
			/// <summary>
			/// The unique identifier for variable file
			/// </summary>
			public const int file = 0x3B;
			/// <summary>
			/// The unique identifier for variable _Axiom_
			/// </summary>
			public const int _Axiom_ = 0x54;
			/// <summary>
			/// The unique identifier for virtual range
			/// </summary>
			public const int range = 0x0;
			/// <summary>
			/// The unique identifier for virtual concat
			/// </summary>
			public const int concat = 0x0;
			/// <summary>
			/// The unique identifier for virtual emptypart
			/// </summary>
			public const int emptypart = 0x0;
		}
		/// <summary>
		/// The collection of variables matched by this parser
		/// </summary>
		/// <remarks>
		/// The variables are in an order consistent with the automaton,
		/// so that variable indices in the automaton can be used to retrieve the variables in this table
		/// </remarks>
		private static readonly Symbol[] variables = {
			new Symbol(0x1E, "option"), 
			new Symbol(0x1F, "terminal_def_atom"), 
			new Symbol(0x20, "terminal_def_element"), 
			new Symbol(0x21, "terminal_def_cardinalilty"), 
			new Symbol(0x22, "terminal_def_repetition"), 
			new Symbol(0x23, "terminal_def_fragment"), 
			new Symbol(0x24, "terminal_def_restrict"), 
			new Symbol(0x25, "terminal_definition"), 
			new Symbol(0x26, "terminal"), 
			new Symbol(0x27, "rule_sym_action"), 
			new Symbol(0x28, "rule_sym_virtual"), 
			new Symbol(0x29, "rule_sym_ref_params"), 
			new Symbol(0x2A, "rule_sym_ref_template"), 
			new Symbol(0x2B, "rule_sym_ref_simple"), 
			new Symbol(0x2C, "rule_def_atom"), 
			new Symbol(0x2D, "rule_def_element"), 
			new Symbol(0x2E, "rule_def_tree_action"), 
			new Symbol(0x2F, "rule_def_repetition"), 
			new Symbol(0x30, "rule_def_fragment"), 
			new Symbol(0x31, "rule_def_choice"), 
			new Symbol(0x32, "rule_definition"), 
			new Symbol(0x33, "rule_template_params"), 
			new Symbol(0x34, "cf_rule_template"), 
			new Symbol(0x35, "cf_rule_simple"), 
			new Symbol(0x36, "grammar_options"), 
			new Symbol(0x37, "grammar_terminals"), 
			new Symbol(0x38, "grammar_cf_rules"), 
			new Symbol(0x39, "grammar_parency"), 
			new Symbol(0x3A, "cf_grammar"), 
			new Symbol(0x3B, "file"), 
			new Symbol(0x43, "_vA"), 
			new Symbol(0x44, "_vB"), 
			new Symbol(0x45, "_vC"), 
			new Symbol(0x48, "_vF"), 
			new Symbol(0x4A, "_v11"), 
			new Symbol(0x4B, "_v12"), 
			new Symbol(0x4C, "_v13"), 
			new Symbol(0x4D, "_v14"), 
			new Symbol(0x4E, "_v15"), 
			new Symbol(0x4F, "_v16"), 
			new Symbol(0x51, "_v18"), 
			new Symbol(0x53, "_v1A"), 
			new Symbol(0x54, "_Axiom_") };
		/// <summary>
		/// The collection of virtuals matched by this parser
		/// </summary>
		/// <remarks>
		/// The virtuals are in an order consistent with the automaton,
		/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
		/// </remarks>
		private static readonly Symbol[] virtuals = {
			new Symbol(0, "range"), 
			new Symbol(0, "concat"), 
			new Symbol(0, "emptypart") };
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		public HimeGrammarParser(HimeGrammarLexer lexer) : base (automaton, variables, virtuals, null, lexer) { }
	}
}

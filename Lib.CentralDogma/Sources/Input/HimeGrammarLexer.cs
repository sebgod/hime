/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 1.0.0.0
 */

using System.Collections.Generic;
using Hime.Redist;
using Hime.Redist.Lexer;

namespace Hime.CentralDogma.Input
{
	/// <summary>
	/// Represents a lexer
	/// </summary>
	internal class HimeGrammarLexer : Lexer
	{
		/// <summary>
		/// The automaton for this lexer
		/// </summary>
		private static readonly Automaton automaton = Automaton.Find(typeof(HimeGrammarLexer), "HimeGrammarLexer.bin");
		/// <summary>
		/// Contains the constant IDs for the terminals for this lexer
		/// </summary>
		public sealed class ID
		{
			/// <summary>
			/// The unique identifier for terminal NAME
			/// </summary>
			public const int NAME = 0x9;
			/// <summary>
			/// The unique identifier for terminal LITERAL_ANY
			/// </summary>
			public const int LITERAL_ANY = 0xD;
			/// <summary>
			/// The unique identifier for terminal OPERATOR_OPTIONAL
			/// </summary>
			public const int OPERATOR_OPTIONAL = 0x14;
			/// <summary>
			/// The unique identifier for terminal OPERATOR_ZEROMORE
			/// </summary>
			public const int OPERATOR_ZEROMORE = 0x15;
			/// <summary>
			/// The unique identifier for terminal OPERATOR_ONEMORE
			/// </summary>
			public const int OPERATOR_ONEMORE = 0x16;
			/// <summary>
			/// The unique identifier for terminal OPERATOR_UNION
			/// </summary>
			public const int OPERATOR_UNION = 0x17;
			/// <summary>
			/// The unique identifier for terminal OPERATOR_DIFFERENCE
			/// </summary>
			public const int OPERATOR_DIFFERENCE = 0x18;
			/// <summary>
			/// The unique identifier for terminal TREE_ACTION_PROMOTE
			/// </summary>
			public const int TREE_ACTION_PROMOTE = 0x19;
			/// <summary>
			/// The unique identifier for terminal TREE_ACTION_DROP
			/// </summary>
			public const int TREE_ACTION_DROP = 0x1A;
			/// <summary>
			/// The unique identifier for terminal SEPARATOR
			/// </summary>
			public const int SEPARATOR = 0x7;
			/// <summary>
			/// The unique identifier for terminal INTEGER
			/// </summary>
			public const int INTEGER = 0xA;
			/// <summary>
			/// The unique identifier for terminal LITERAL_STRING
			/// </summary>
			public const int LITERAL_STRING = 0xB;
			/// <summary>
			/// The unique identifier for terminal UNICODE_SPAN_MARKER
			/// </summary>
			public const int UNICODE_SPAN_MARKER = 0x13;
			/// <summary>
			/// The unique identifier for terminal ESCAPEES
			/// </summary>
			public const int ESCAPEES = 0xC;
			/// <summary>
			/// The unique identifier for terminal UNICODE_CODEPOINT
			/// </summary>
			public const int UNICODE_CODEPOINT = 0x12;
			/// <summary>
			/// The unique identifier for terminal LITERAL_CLASS
			/// </summary>
			public const int LITERAL_CLASS = 0xF;
			/// <summary>
			/// The unique identifier for terminal LITERAL_TEXT
			/// </summary>
			public const int LITERAL_TEXT = 0xE;
			/// <summary>
			/// The unique identifier for terminal UNICODE_BLOCK
			/// </summary>
			public const int UNICODE_BLOCK = 0x10;
			/// <summary>
			/// The unique identifier for terminal UNICODE_CATEGORY
			/// </summary>
			public const int UNICODE_CATEGORY = 0x11;
			/// <summary>
			/// The unique identifier for terminal BLOCK_RULES
			/// </summary>
			public const int BLOCK_RULES = 0x1D;
			/// <summary>
			/// The unique identifier for terminal BLOCK_OPTIONS
			/// </summary>
			public const int BLOCK_OPTIONS = 0x1B;
			/// <summary>
			/// The unique identifier for terminal BLOCK_TERMINALS
			/// </summary>
			public const int BLOCK_TERMINALS = 0x1C;
		}
		/// <summary>
		/// The collection of terminals matched by this lexer
		/// </summary>
		/// <remarks>
		/// The terminals are in an order consistent with the automaton,
		/// so that terminal indices in the automaton can be used to retrieve the terminals in this table
		/// </remarks>
		private static readonly Symbol[] terminals = {
			new Symbol(0x1, "Îµ"),
			new Symbol(0x2, "$"),
			new Symbol(0x9, "NAME"),
			new Symbol(0xD, "LITERAL_ANY"),
			new Symbol(0x14, "OPERATOR_OPTIONAL"),
			new Symbol(0x15, "OPERATOR_ZEROMORE"),
			new Symbol(0x16, "OPERATOR_ONEMORE"),
			new Symbol(0x17, "OPERATOR_UNION"),
			new Symbol(0x18, "OPERATOR_DIFFERENCE"),
			new Symbol(0x19, "TREE_ACTION_PROMOTE"),
			new Symbol(0x1A, "TREE_ACTION_DROP"),
			new Symbol(0x3C, "="),
			new Symbol(0x3D, ";"),
			new Symbol(0x3E, "("),
			new Symbol(0x3F, ")"),
			new Symbol(0x40, "{"),
			new Symbol(0x41, ","),
			new Symbol(0x42, "}"),
			new Symbol(0x47, "<"),
			new Symbol(0x49, ">"),
			new Symbol(0x50, ":"),
			new Symbol(0x7, "SEPARATOR"),
			new Symbol(0xA, "INTEGER"),
			new Symbol(0xB, "LITERAL_STRING"),
			new Symbol(0x13, "UNICODE_SPAN_MARKER"),
			new Symbol(0x46, "->"),
			new Symbol(0xC, "ESCAPEES"),
			new Symbol(0x12, "UNICODE_CODEPOINT"),
			new Symbol(0xF, "LITERAL_CLASS"),
			new Symbol(0xE, "LITERAL_TEXT"),
			new Symbol(0x10, "UNICODE_BLOCK"),
			new Symbol(0x11, "UNICODE_CATEGORY"),
			new Symbol(0x1D, "BLOCK_RULES"),
			new Symbol(0x1B, "BLOCK_OPTIONS"),
			new Symbol(0x52, "grammar"),
			new Symbol(0x1C, "BLOCK_TERMINALS") };
		/// <summary>
		/// Initializes a new instance of the lexer
		/// </summary>
		/// <param name="input">The lexer's input</param>
		public HimeGrammarLexer(string input) : base(automaton, terminals, 0x7, new System.IO.StringReader(input)) {}
		/// <summary>
		/// Initializes a new instance of the lexer
		/// </summary>
		/// <param name="input">The lexer's input</param>
		public HimeGrammarLexer(System.IO.TextReader input) : base(automaton, terminals, 0x7, input) {}
	}
}

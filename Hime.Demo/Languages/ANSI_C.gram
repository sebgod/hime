public cf text grammar ANSI_C {
	options {
		Axiom = "translation_unit";
		Separator = "SEPARATOR";
	}
	terminals {
		NEW_LINE		-> 0x000D /* CR */
						|  0x000A /* LF */
						|  0x000D 0x000A /* CR LF */
						|  0x2028 /* LS */
						|  0x2029 /* PS */ ;
		WHITE_SPACE		-> 0x0020 | 0x0009 | 0x000B | 0x000C ;
		COMMENT_LINE	-> '//' (.* - (.* NEW_LINE .*)) NEW_LINE ;
		COMMENT_BLOCK	-> '/*' (.* - (.* '*/' .*)) '*/' ;
		SEPARATOR		-> (NEW_LINE | WHITE_SPACE | COMMENT_LINE | COMMENT_BLOCK)+;
		
		IDENTIFIER		-> [a-zA-Z_] [a-zA-Z0-9_]* ;
		
		NULL_LITTERAL				-> 'null' ;
		BOOLEAN_LITTERAL_TRUE		-> 'true' ;
		BOOLEAN_LITTERAL_FALSE		-> 'false' ;
		INTEGER_LITTERAL_SUFFIX		-> ('u'|'U'|'l'|'L') ;
		INTEGER_LITTERAL_DECIMAL	-> [1-9] [0-9]* | '0' INTEGER_LITTERAL_SUFFIX? ;
		INTEGER_LITTERAL_HEXA		-> '0' ('x' | 'X') [a-fA-F0-9]+ INTEGER_LITTERAL_SUFFIX? ;
		REAL_LITTERAL_SUFFIX		-> ('f'|'F'|'l'|'L') ;
		REAL_LITTERAL				-> INTEGER_LITTERAL_DECIMAL? '.' INTEGER_LITTERAL_DECIMAL  (('e' | 'E') ('+' | '-')? INTEGER_LITTERAL_DECIMAL)? REAL_LITTERAL_SUFFIX?
									|  INTEGER_LITTERAL_DECIMAL ('e' | 'E') ('+' | '-')? INTEGER_LITTERAL_DECIMAL REAL_LITTERAL_SUFFIX?
									|  INTEGER_LITTERAL_DECIMAL REAL_LITTERAL_SUFFIX ;
		CHARACTER_LITTERAL			-> '\'' ( (0x0000 .. 0xFFFF - ('\'' | '\\' | NEW_LINE))
											| '\\' ('\'' | '"' | '\'' | '\\' | [0abfnrtv])
											| '\\' 'x' [a-fA-F0-9] [a-fA-F0-9]? [a-fA-F0-9]? [a-fA-F0-9]?
											| '\\' ('u' | 'U') [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] ([a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9])?
										) '\'' ;
		STRING_LITERAL		-> '"'  ( (0x0000 .. 0xFFFF - ('"' | '\\' | NEW_LINE))
									| '\\' ('\'' | '"' | '\'' | '\\' | [0abfnrtv])
									| '\\' 'x' [a-fA-F0-9] [a-fA-F0-9]? [a-fA-F0-9]? [a-fA-F0-9]?
									| '\\' ('u' | 'U') [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] ([a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9])?
								)* '"' ;
	}
	rules {
		/* A.2.1 Expressions */
		
		primary_expression -> IDENTIFIER
			| NULL_LITTERAL
			| BOOLEAN_LITTERAL_TRUE
			| BOOLEAN_LITTERAL_FALSE
			| INTEGER_LITTERAL_DECIMAL
			| INTEGER_LITTERAL_HEXA
			| REAL_LITTERAL
			| CHARACTER_LITTERAL
			| STRING_LITERAL
			| '(' expression ')' ;

		postfix_expression -> primary_expression
			| postfix_expression '[' expression ']'
			| postfix_expression '(' argument_expression_list? ')'
			| postfix_expression '.' IDENTIFIER
			| postfix_expression '->' IDENTIFIER
			| postfix_expression '++'
			| postfix_expression '--' ;

		argument_expression_list -> assignment_expression (',' assignment_expression)* ;

		unary_expression -> postfix_expression
			| '++' unary_expression
			| '--' unary_expression
			| '&' cast_expression
			| '*' cast_expression
			| '+' cast_expression
			| '-' cast_expression
			| '~' cast_expression
			| '!' cast_expression
			| 'sizeof' unary_expression
			| 'sizeof' '(' type_name ')'
			;

		cast_expression -> unary_expression
			| '(' type_name ')' cast_expression
			;

		multiplicative_expression -> cast_expression
			| multiplicative_expression '*' cast_expression
			| multiplicative_expression '/' cast_expression
			| multiplicative_expression '%' cast_expression
			;

		additive_expression -> multiplicative_expression
			| additive_expression '+' multiplicative_expression
			| additive_expression '-' multiplicative_expression
			;

		shift_expression -> additive_expression
			| shift_expression '<<' additive_expression
			| shift_expression '>>' additive_expression
			;

		relational_expression -> shift_expression
			| relational_expression '<' shift_expression
			| relational_expression '>' shift_expression
			| relational_expression '<=' shift_expression
			| relational_expression '>=' shift_expression
			;

		equality_expression -> relational_expression
			| equality_expression '==' relational_expression
			| equality_expression '!=' relational_expression
			;

		and_expression -> equality_expression
			| and_expression '&' equality_expression
			;

		exclusive_or_expression -> and_expression
			| exclusive_or_expression '^' and_expression
			;

		inclusive_or_expression -> exclusive_or_expression
			| inclusive_or_expression '|' exclusive_or_expression
			;

		logical_and_expression -> inclusive_or_expression
			| logical_and_expression '&&' inclusive_or_expression
			;

		logical_or_expression -> logical_and_expression
			| logical_or_expression '||' logical_and_expression
			;

		conditional_expression -> logical_or_expression
			| logical_or_expression '?' expression ':' conditional_expression
			;

		assignment_expression -> conditional_expression
			| unary_expression '=' assignment_expression
			| unary_expression '*=' assignment_expression
			| unary_expression '/=' assignment_expression
			| unary_expression '%=' assignment_expression
			| unary_expression '+=' assignment_expression
			| unary_expression '-=' assignment_expression
			| unary_expression '<<=' assignment_expression
			| unary_expression '>>=' assignment_expression
			| unary_expression '&=' assignment_expression
			| unary_expression '^=' assignment_expression
			| unary_expression '|=' assignment_expression
			;

		expression -> assignment_expression
			| expression ',' assignment_expression
			;

		constant_expression -> conditional_expression
			;

			
			
		/* A.2.2 Declarations */
		
		declaration -> declaration_specifiers init_declarator_list? ';' ;

		declaration_specifiers -> storage_class_specifier declaration_specifiers?
								| type_specifier declaration_specifiers?
								| type_qualifier declaration_specifiers?
								;

		init_declarator_list -> init_declarator
			| init_declarator_list ',' init_declarator
			;

		init_declarator -> declarator
			| declarator '=' initializer
			;

		storage_class_specifier -> 'typedef'
			| 'extern'
			| 'static'
			| 'auto'
			| 'register'
			;

		type_specifier -> 'void'
						| 'char'
						| 'short'
						| 'int'
						| 'long'
						| 'float'
						| 'double'
						| 'signed'
						| 'unsigned'
						| struct_or_union_specifier
						| enum_specifier
						| IDENTIFIER ;

		struct_or_union_specifier -> struct_or_union IDENTIFIER '{' struct_declaration_list '}'
			| struct_or_union '{' struct_declaration_list '}'
			| struct_or_union IDENTIFIER
			;

		struct_or_union -> 'struct'
			| 'union'
			;

		struct_declaration_list -> struct_declaration
			| struct_declaration_list struct_declaration
			;

		struct_declaration -> specifier_qualifier_list struct_declarator_list ';'
			;

		specifier_qualifier_list -> type_specifier specifier_qualifier_list
			| type_specifier
			| type_qualifier specifier_qualifier_list
			| type_qualifier
			;

		struct_declarator_list -> struct_declarator
			| struct_declarator_list ',' struct_declarator
			;

		struct_declarator -> declarator
			| ':' constant_expression
			| declarator ':' constant_expression
			;

		enum_specifier -> 'enum' '{' enumerator_list '}'
			| 'enum' IDENTIFIER '{' enumerator_list '}'
			| 'enum' IDENTIFIER
			;

		enumerator_list -> enumerator
			| enumerator_list ',' enumerator
			;

		enumerator -> IDENTIFIER
			| IDENTIFIER '=' constant_expression
			;

		type_qualifier -> 'const'
			| 'volatile'
			;

		declarator -> pointer direct_declarator
			| direct_declarator
			;

		direct_declarator -> IDENTIFIER
			| '(' declarator ')'
			| direct_declarator '[' constant_expression ']'
			| direct_declarator '[' ']'
			| direct_declarator '(' parameter_type_list ')'
			| direct_declarator '(' identifier_list ')'
			| direct_declarator '(' ')'
			;

		pointer -> '*'
			| '*' type_qualifier_list
			| '*' pointer
			| '*' type_qualifier_list pointer
			;

		type_qualifier_list -> type_qualifier
			| type_qualifier_list type_qualifier
			;


		parameter_type_list -> parameter_list
			| parameter_list ',' '...'
			;

		parameter_list -> parameter_declaration
			| parameter_list ',' parameter_declaration
			;

		parameter_declaration -> declaration_specifiers declarator
			| declaration_specifiers abstract_declarator
			| declaration_specifiers
			;

		identifier_list -> IDENTIFIER
			| identifier_list ',' IDENTIFIER
			;

		type_name -> specifier_qualifier_list
			| specifier_qualifier_list abstract_declarator
			;

		abstract_declarator -> pointer
			| direct_abstract_declarator
			| pointer direct_abstract_declarator
			;

		direct_abstract_declarator -> '(' abstract_declarator ')'
			| '[' ']'
			| '[' constant_expression ']'
			| direct_abstract_declarator '[' ']'
			| direct_abstract_declarator '[' constant_expression ']'
			| '(' ')'
			| '(' parameter_type_list ')'
			| direct_abstract_declarator '(' ')'
			| direct_abstract_declarator '(' parameter_type_list ')'
			;

		initializer -> assignment_expression
			| '{' initializer_list '}'
			| '{' initializer_list ',' '}'
			;

		initializer_list -> initializer
			| initializer_list ',' initializer
			;

		statement -> labeled_statement
			| compound_statement
			| expression_statement
			| selection_statement
			| iteration_statement
			| jump_statement
			;

		labeled_statement -> IDENTIFIER ':' statement
			| 'case' constant_expression ':' statement
			| 'default' ':' statement
			;

		compound_statement -> '{' '}'
			| '{' statement_list '}'
			| '{' declaration_list '}'
			| '{' declaration_list statement_list '}'
			;

		declaration_list -> declaration
			| declaration_list declaration
			;

		statement_list -> statement
			| statement_list statement
			;

		expression_statement -> ';'
			| expression ';'
			;

		selection_statement -> 'if' '(' expression ')' statement
			| 'if' '(' expression ')' statement 'else' statement
			| 'switch' '(' expression ')' statement
			;

		iteration_statement -> 'while' '(' expression ')' statement
			| 'do' statement 'while' '(' expression ')' ';'
			| 'for' '(' expression_statement expression_statement ')' statement
			| 'for' '(' expression_statement expression_statement expression ')' statement
			;

		jump_statement -> 'goto' IDENTIFIER ';'
			| 'continue' ';'
			| 'break' ';'
			| 'return' ';'
			| 'return' expression ';'
			;

		translation_unit -> external_declaration
			| translation_unit external_declaration
			;

		external_declaration -> function_definition
			| declaration
			;

		function_definition -> declaration_specifiers declarator declaration_list compound_statement
			| declaration_specifiers declarator compound_statement
			| declarator declaration_list compound_statement
			| declarator compound_statement
			;
	}
}